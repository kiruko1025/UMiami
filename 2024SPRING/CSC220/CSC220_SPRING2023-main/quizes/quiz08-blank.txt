0. Given E[] theArray, write code so that for 0 <= i < theArray.length,
   map.get(theArray[i]) is the number of times item theArray[i] appears in theArray.

	Map<E, Integer> map = new HashMap<E, Integer>();











1. This implementation of Insertion Sort crashes sometimes.  How do you fix it?

    for (int n = 0; n < array.length; n++) {
      E data = array[n];
      int i = n;
      while (array[i-1].compareTo(data) > 0) {
        array[i] = array[i-1];
        i--;
      }
      array[i] = data;
    }




2. Show the individual changes to the array for the next insertion (the 2) in
   Insertion Sort.  Write out the entire array each time.

1 1 3 5 9 2 6
---------



3. Heap Sort is in first, heapifying phase.  Show the sequence of required swaps to
   finish putting the array into heap order with the **LARGEST** on top.  You can
   use the tree version.  (Each parent should be >= its children.)

3 1 9 6 5 4 2 1

3
1       9
6   5   4   2
1



4. Heap Sort is in the removal phase.  The 9 has already been removed (size==7).
   Show the entire array (or tree) after each swap used to remove the 6.

6 4 5 1 1 3 2 9
-------------

6
4       5
1   1   3   2
(9)




5. Quick Sort is using 4 as the pivot.  Show the swaps that partition it into
   elements <4 and >=4.  Then show the swaps to partition >=4 into =4 and >4.

3 1 4 4 5 9 2 6








For questions 6-9:

	a) Is it stable?

	b) What is the worst case O() running time?

	c) What property does it have that the other three don't?


6. Insertion Sort.

a)

b)

c)




7. Quick Sort in place using random element element as pivot.

a)

b)

c)




8. Heap Sort.

a)

b)

c)




9. Merge Sort.

a)

b)

c)

